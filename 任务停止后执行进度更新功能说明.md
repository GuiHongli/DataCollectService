# 任务停止后执行进度更新功能说明

## 功能概述

为了确保任务停止后能够准确反映当前的执行状态，我们在CollectTaskController的停止任务功能中增加了执行进度更新逻辑。当用户点击停止按钮时，系统不仅会停止任务和终止相关进程，还会同时更新采集任务和用例执行例次的执行进度。

## 功能特性

### 1. 完整的停止流程
- **任务状态更新**: 将采集任务状态更新为STOPPED
- **远程进程终止**: 调用CaseExecuteService取消正在执行的任务
- **例次状态更新**: 将所有RUNNING状态的用例执行例次更新为STOPPED
- **执行进度更新**: 重新计算并更新任务的执行进度统计

### 2. 执行进度统计
- **总数统计**: 统计任务的所有用例执行例次总数
- **状态统计**: 按状态分类统计（成功、失败、阻塞、停止、执行中）
- **结果统计**: 按执行结果分类统计（SUCCESS、FAILED、BLOCKED）
- **实时更新**: 基于最新的例次状态进行进度计算

### 3. 数据一致性保证
- **状态同步**: 确保任务状态和例次状态的一致性
- **进度同步**: 确保进度统计与实际执行情况一致
- **错误处理**: 对更新过程中的异常进行妥善处理

## 技术实现

### 1. 停止任务流程增强

#### 1.1 原有流程
```java
@PostMapping("/{id}/stop")
public Result<Boolean> stopTask(@PathVariable @NotNull Long id) {
    // 1. 更新任务状态为STOPPED
    collectTaskService.updateTaskStatus(id, "STOPPED");
    
    // 2. 获取RUNNING状态的例次
    List<TestCaseExecutionInstance> runningInstances = 
        testCaseExecutionInstanceService.getByCollectTaskIdAndStatus(id, "RUNNING");
    
    // 3. 调用CaseExecuteService取消任务
    for (TestCaseExecutionInstance instance : runningInstances) {
        caseExecuteServiceClient.cancelTaskExecution(instance.getExecutorIp(), instance.getExecutionTaskId());
        testCaseExecutionInstanceService.updateExecutionStatus(instance.getId(), "STOPPED", null);
    }
}
```

#### 1.2 增强后的流程
```java
@PostMapping("/{id}/stop")
public Result<Boolean> stopTask(@PathVariable @NotNull Long id) {
    // 1. 更新任务状态为STOPPED
    collectTaskService.updateTaskStatus(id, "STOPPED");
    
    // 2. 获取RUNNING状态的例次
    List<TestCaseExecutionInstance> runningInstances = 
        testCaseExecutionInstanceService.getByCollectTaskIdAndStatus(id, "RUNNING");
    
    // 3. 调用CaseExecuteService取消任务
    for (TestCaseExecutionInstance instance : runningInstances) {
        caseExecuteServiceClient.cancelTaskExecution(instance.getExecutorIp(), instance.getExecutionTaskId());
        testCaseExecutionInstanceService.updateExecutionStatus(instance.getId(), "STOPPED", null);
    }
    
    // 4. 更新采集任务和用例执行例次的执行进度
    updateTaskExecutionProgress(id);
}
```

### 2. 执行进度更新方法

#### 2.1 方法实现
```java
private void updateTaskExecutionProgress(Long taskId) {
    try {
        log.info("开始更新任务执行进度 - 任务ID: {}", taskId);
        
        // 获取任务的所有用例执行例次
        List<TestCaseExecutionInstance> instances = 
            testCaseExecutionInstanceService.getByCollectTaskId(taskId);
        
        if (instances.isEmpty()) {
            log.warn("任务没有用例执行例次 - 任务ID: {}", taskId);
            return;
        }
        
        // 统计各种状态和结果的数量
        int totalCount = instances.size();
        int successCount = 0;
        int failedCount = 0;
        int blockedCount = 0;
        int stoppedCount = 0;
        int runningCount = 0;
        
        for (TestCaseExecutionInstance instance : instances) {
            String status = instance.getStatus();
            String result = instance.getResult();
            
            // 统计状态
            switch (status) {
                case "RUNNING":
                    runningCount++;
                    break;
                case "STOPPED":
                    stoppedCount++;
                    break;
                case "COMPLETED":
                    // 根据执行结果统计
                    if ("SUCCESS".equals(result)) {
                        successCount++;
                    } else if ("FAILED".equals(result)) {
                        failedCount++;
                    } else if ("BLOCKED".equals(result)) {
                        blockedCount++;
                    }
                    break;
                default:
                    // 其他状态（如PENDING）不计入统计
                    break;
            }
        }
        
        log.info("任务执行进度统计 - 任务ID: {}, 总数: {}, 成功: {}, 失败: {}, 阻塞: {}, 停止: {}, 执行中: {}", 
                taskId, totalCount, successCount, failedCount, blockedCount, stoppedCount, runningCount);
        
        // 更新采集任务的执行进度
        boolean progressUpdated = collectTaskService.updateTaskProgress(taskId, totalCount, successCount, failedCount);
        if (progressUpdated) {
            log.info("采集任务执行进度更新成功 - 任务ID: {}", taskId);
        } else {
            log.error("采集任务执行进度更新失败 - 任务ID: {}", taskId);
        }
        
    } catch (Exception e) {
        log.error("更新任务执行进度异常 - 任务ID: {}, 错误: {}", taskId, e.getMessage(), e);
    }
}
```

### 3. 进度统计逻辑

#### 3.1 状态分类
- **RUNNING**: 正在执行的用例例次
- **STOPPED**: 已停止的用例例次
- **COMPLETED**: 已完成的用例例次
  - 根据result字段进一步分类：
    - SUCCESS: 执行成功
    - FAILED: 执行失败
    - BLOCKED: 执行被阻塞

#### 3.2 统计规则
- **总数**: 所有用例执行例次的数量
- **成功数**: 状态为COMPLETED且结果为SUCCESS的例次数量
- **失败数**: 状态为COMPLETED且结果为FAILED的例次数量
- **阻塞数**: 状态为COMPLETED且结果为BLOCKED的例次数量
- **停止数**: 状态为STOPPED的例次数量
- **执行中数**: 状态为RUNNING的例次数量

## 执行流程

### 1. 用户操作
1. 用户在任务列表页面点击"停止"按钮
2. 前端调用`POST /api/collect-task/{id}/stop`接口

### 2. 任务停止处理
1. 验证任务是否存在
2. 更新任务状态为STOPPED
3. 查询所有RUNNING状态的用例执行例次
4. 对每个正在执行的例次：
   - 调用CaseExecuteService取消任务
   - 更新例次状态为STOPPED

### 3. 执行进度更新
1. 调用`updateTaskExecutionProgress`方法
2. 获取任务的所有用例执行例次
3. 按状态和结果进行分类统计
4. 更新采集任务的执行进度
5. 记录详细的统计日志

### 4. 返回结果
1. 返回停止操作的结果
2. 前端可以刷新页面查看最新的执行进度

## 数据库更新

### 1. 采集任务表 (collect_task)
```sql
UPDATE collect_task 
SET total_test_case_count = ?, 
    success_test_case_count = ?, 
    failed_test_case_count = ?, 
    update_time = NOW()
WHERE id = ?
```

### 2. 用例执行例次表 (test_case_execution_instance)
```sql
UPDATE test_case_execution_instance 
SET status = 'STOPPED', 
    update_time = NOW()
WHERE collect_task_id = ? AND status = 'RUNNING'
```

## 错误处理

### 1. 异常处理
- **数据获取异常**: 如果获取用例执行例次失败，记录警告日志但不影响主流程
- **进度更新异常**: 如果进度更新失败，记录错误日志但不影响任务停止
- **网络调用异常**: 如果CaseExecuteService调用失败，记录错误但继续处理其他例次

### 2. 日志记录
- **详细日志**: 记录每个步骤的执行情况
- **统计日志**: 记录最终的统计结果
- **错误日志**: 记录所有异常情况

## 监控和验证

### 1. 关键指标
- **停止成功率**: 任务停止操作的成功率
- **进度更新成功率**: 执行进度更新的成功率
- **状态一致性**: 任务状态和例次状态的一致性

### 2. 验证方法
1. **功能测试**: 创建正在执行的任务，点击停止按钮，验证进度更新
2. **数据验证**: 检查数据库中的进度统计是否正确
3. **日志验证**: 检查日志中的统计信息是否准确

## 总结

通过这次功能增强，我们实现了：

1. **完整的停止流程**: 从任务停止到进度更新的完整链路
2. **准确的进度统计**: 基于真实数据计算执行进度
3. **数据一致性**: 确保任务状态和进度统计的一致性
4. **错误处理**: 对各种异常情况进行妥善处理
5. **详细日志**: 记录所有关键操作，便于问题排查

这个功能确保了用户能够准确了解任务停止后的执行状态，提高了系统的可靠性和用户体验。
